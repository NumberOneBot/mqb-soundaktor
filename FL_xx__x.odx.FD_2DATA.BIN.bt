//------------------------------------------------
//--- 010 Editor v12.0 Binary Template
//
//      File: FL_xx__x.odx.FD_2DATA.BIN
//   Authors: Jille, Dark
//   Version: 0.9
//   Purpose: Parse the contents of the MQB soundaktor firmware
//  Category: 
// File Mask: 
//  ID Bytes: 
//   History: 0.1 - Initial version
//            0.2 - Additional field descriptions taken from MxCar sheet   
//            0.3.1 - 10 out of 12 tables mapped
//            0.3.2 - Gain table key     
//            0.4 - Parsed and visualized all the tables found at this moment 
//            0.5 - Transposed some tables to be viewed in the right way
//            0.6 - Added Lib_Sig (whatever it may be.. noise signature?)
//            0.7 - template code cleanup, started GEN2.5 parsing
//            0.9 - GEN2 finished, GEN2.5 work in progress
//------------------------------------------------
// legend: 
// yellow/aqua = uncertain
// red         = unknown
// green       = confirmed
// gray        = seemingly irrelevant
// blue        = special
// purple      = potential checksum

// LOCAL VARIABLES

local int i = 0;
local int j = 0;
local int k = 0;
local float x = 0;
local int factor = 0;
local string format = "";
local int checksum = -1;
local int start = 0x02;
local int end = 0xE000;
local int GEN25 = (FileSize() == 0x18000 ? 1 : 0);
if (GEN25) {
    end = 0x18000;
}


// FUNCTIONS

void PrintHeader( char name[] ) {
    Printf("\n%s\n", name);
    Printf("BOOST\t\t\tHYBRID\t\t\tEFFICIENCY\n");
    Printf("Normal\tSport\tEco\tNormal\tSport\tEco\tNormal\tSport\n");
}

void PrintSheet12( char name[], struct sheet12x8 sheet, int factor, string format) {
    PrintHeader( name );
    for ( j = 0; j < 12; j++ ) {
        for( i = 0; i < 8; i++ ) {
            Printf(format, (float) sheet[i].value[j] / factor);
        }
        Printf("\n");
    };
}

void PrintSheet12_Q16( char name[], struct sheet12x8 sheet) {
    PrintHeader( name );
    for( j = 0; j < 12; j++ ) {
        for ( i = 0; i < 8; i++ ) {
            // there is definitelly a rounding issue exists
            // trying to compensate it with 1.006 multiplier
            x = (float) sheet[i].value[j] * 1.006 / 16;
            Printf("%.3g°\t", x);
        }
        Printf("\n");
    };			 
} 

void PrintSheet12b( char name[], struct sheet12x8bytes sheet) {
    PrintHeader( name + " UBYTE" );
    for ( j = 0; j < 12; j++ ) {
        for( i = 0; i < 8; i++ ) {
            Printf("%i\t", sheet[i].value[j] + 1); // not sure do we need this +1
        }
        Printf("\n");
    };			 
} 

void PrintSheet2( char name[], struct sheet8x2 sheet) {
    PrintHeader( name + " USHORT" );
    for ( j = 0; j < 8; j++ ) {
        Printf("%.3g\t", (float) sheet[0].value[j]/65536 * 2); // 0 < X < 1 // Q:65536
    }
    Printf("\n");
    for ( j = 0; j < 8; j++ ) {
        Printf("%.3g\t", (float) sheet[1].value[j]/65536 * 512); // 0 < X < 8 // Q:65536
    }
    Printf("\n");
} 

string getFilterProperties(int filterSetting) {
   switch (filterSetting) {
        case 0x00: return "no filter";     
        case 0x01: return "50Hz/6dB";      
        case 0x02: return "100Hz/6dB";     
        case 0x03: return "150Hz/6dB";
        case 0x04: return "200Hz/6dB";     
        case 0x05: return "250Hz/6dB";     
        case 0x06: return "300Hz/6dB"; 
        case 0x07: return "350Hz/6dB";     
        case 0x08: return "400Hz/6dB";     
        case 0x09: return "450Hz/6dB"; 
        case 0x0A: return "50Hz/12dB";     
        case 0x0B: return "100Hz/12dB";    
        case 0x0C: return "150Hz/12dB"; 
        case 0x0D: return "200Hz/12dB"; 
        case 0x0E: return "250Hz/12dB";    
        case 0x0F: return "300Hz/12dB"; 
        case 0x10: return "350Hz/12dB"; 
        case 0x11: return "400Hz/12dB";    
        case 0x12: return "450Hz/12dB";
        default:   return "Unknown";
   }
}

string getSampleRate(int sampleRate) {
    switch (sampleRate) {
        case 0: return "512";    
        case 1: return "1024";    
        case 2: return "2048";    
        case 3: return "4096";   
        case 4: return "8192";    
        case 5: return "16384";    
        case 6: return "32768";    
        default:return "Unknown";
    }
}


// START PARSING

LittleEndian();

ushort file_checksum <bgcolor=cPurple >; //some kind of checksum? 
byte unknown_2 <bgcolor=cDkYellow>; 
byte Gain_table_flag <bgcolor=cYellow>;

ushort Profiles <bgcolor=cLtBlue>; 
ushort Effects <bgcolor=cLtGreen>; 
ushort RevsFunctions <bgcolor=cLtBlue>; // engine revolutions / LIB_n_Gain_height
ushort AccelFunctions <bgcolor=cLtGreen>; // acceleration / G-meter / LIB_m_Gain_height
ushort SpeedFunctions <bgcolor=cLtBlue>; // speed / LIB_v_Gain_height

if (GEN25) {
    ushort PedalFunctions <bgcolor=cLtBlue>;
} else {

    ushort Revolutions_length <bgcolor=cLtGreen>;
    ushort Acceleration_length <bgcolor=cLtBlue>;
    ushort Speed_length <bgcolor=cLtGreen>;
    ushort Acceleration_Table_size <bgcolor=cLtBlue>; // size of LIB_m_Gain table in bytes, 512
    ushort Revolutions_Table_size <bgcolor=cLtGreen>; // size of LIB_n_Gain table in bytes, 8192
    ushort Profiles_2 <bgcolor=cLtBlue>;
    ushort Effects_2 <bgcolor=cLtGreen>; 
    ushort RevsFunctions_2 <bgcolor=cLtBlue>; 
    ushort AccelFunctions_2 <bgcolor=cLtBlue>; 
    ushort SpeedFunctions_2 <bgcolor=cLtBlue>;
    // the following 2 values are linked to SampleRate 
    // Depending on the value there, the values here are different.
    ushort Samples_count <bgcolor=cLtGreen>; // LIB_Sig
    ushort Sample_length <bgcolor=cGreen>;   // LIB_Sig
    ushort Damping_factor <bgcolor=cLtBlue>; // Range 0-65535 
}
// Offset where the filename starts.
FSeek(62);
ushort source_filename_checksum <bgcolor=cPurple>;// CRC16-CCITT
char source_filename[64] <bgcolor=cDkGreen>;

ushort Profiles_3 <bgcolor=cLtBlue>; 
if (GEN25) {
    ushort Effects_3 <bgcolor=cLtGreen>;
}
ushort RevsFunctions_3 <bgcolor=cLtGreen>;
ushort AccelFunctions_3 <bgcolor=cLtBlue>; 
ushort SpeedFunctions_3 <bgcolor=cLtGreen>;
if (!GEN25) {
    ushort Samples_Count_2 <bgcolor=cLtBlue>; 
    ushort Sample_Rate <bgcolor=cLtGreen, read=getSampleRate>;
    ushort Damping_factor_2 <bgcolor=cLtBlue>; // 0 <= DF <= 1 Quantization 0-65535
    // they refer to it as initial speed value in GEN2 ???? (always set to 0!)
    ushort unknown_18 <bgcolor=cDkYellow>; 
} else {
    ushort PedalFunctions_2 <bgcolor=cLtBlue>; 
    ushort unknown_19 <bgcolor=cYellow>;
    ushort unknown_20 <bgcolor=cDkYellow>;
    ushort unknown_21 <bgcolor=cYellow>;
    ushort unknown_22 <bgcolor=cDkYellow>;
    ushort unknown_23 <bgcolor=cYellow>;
    ushort unknown_24 <bgcolor=cDkYellow>;
    ushort unknown_25 <bgcolor=cYellow>;
    ushort unknown_26 <bgcolor=cDkYellow>;
    ushort unknown_27 <bgcolor=cYellow>;
    ushort unknown_28 <bgcolor=cDkYellow>;
}

Printf("%s \n\n", source_filename);
if (!GEN25) {
    Printf("GEN2 firmware\n\n");

    struct {
        ubyte Engine_code <bgcolor=cDkGreen>;
        char VIN_mask[17] <bgcolor=cGreen>;
        ubyte Charisma_01_Switch_Relapse_Clamp15 <bgcolor=cDkGreen>;   
        ubyte Charisma_02_Switch_Gearbox <bgcolor=cGreen>;
        ubyte Charisma_03_Default_driving_profile <bgcolor=cDkGreen>;
        ubyte Charisma_04_Reverse_driving_profile <bgcolor=cGreen>;
        ubyte Charisma_05_Comfort_driving_profile <bgcolor=cDkGreen>;
        ubyte Charisma_06_Normal_driving_profile <bgcolor=cGreen>;
        ubyte Charisma_07_Sport_driving_profile <bgcolor=cDkGreen>;
        ubyte Charisma_08_Offroad_driving_profile <bgcolor=cGreen>; 
        ubyte Charisma_09_Eco_driving_profile <bgcolor=cDkGreen>;
        ubyte Charisma_10_Race_driving_profile  <bgcolor=cGreen>;
        ubyte Charisma_11_GTE_driving_profile  <bgcolor=cDkGreen>;
        ubyte HighPass_filter <bgcolor=cGreen, read=getFilterProperties>;  
        ubyte Reserved_for_future_use_2 <bgcolor=cGray>;  
        ubyte PHEV_button_led_bits <bgcolor=cGray>; // 335 only
    } Car[Profiles];                                    
    
    // Engine codes
    
    // 06 - high-perf 2.0l diesel engine? CUNA / CUPA / CUBA 190hp+ 
    // 07 - mid-perf DFGA (could cover DFE also, maybe CRL too) Kodiaq 150hp 2.0l diesel 
    // 0C - CEPA / CZGB 2.5l I5 engine
    // 17 - DAZA 2.5l 340+hp 
    // 29 - MLB-version of high-perf 2.0l
    // 2B - CJX 2.0l 220+hp GTI, S3, SQ2, etc
    // 2A - CJS 1.8 Leon FR 170+hp
    // 42 - CJE / CPK / CPR 1.8 Leon FR
    // 45 - something between CJX and higher-perf 2.5l engines, maybe overtuned CJX from Clubsport models? 260-280hp
    // 32 - Passat PHEV / Tiguan PHEV, 2.0l maybe?
    // 13 - CUK 1.4TSI GTE, Bora / Lavida / Golf
    // 14 - old-school A4 diesels 2.0l / 2.7l / 3.0l
    // 2D - A6 diesel ? 
    // 48 - CWGD / DLZA V6 3.0l 350hp S4 
    // 49 - DECA / DKMB V6 2.9l 450hp RS4 / RS5
    // 5A - ???
    // 3F - ANY 
    // D5 - S3 8Y
    // E4 - S3 8Y
    // D8 - Urus V8


    struct {
        ushort value[Effects];
    } Gain_Effect[Profiles] <bgcolor=cDkGreen, optimize=true>; 
    struct {
        ushort value[Effects];
    } Phase_Effect[Profiles] <bgcolor=cGreen, optimize=true>; 
    struct {
        ushort value[Effects];
    } Pitch_Shift_Effect[Profiles] <bgcolor=cDkGreen, optimize=true>;
    struct {
        ushort value[Effects];
    } Delay_Effect[Profiles] <bgcolor=cGreen, optimize=true>;
    struct {
        byte value[Effects];
    } Effects_to_Accel[Profiles] <bgcolor=cDkGreen, optimize=true>;
    struct {
        byte value[Effects];
    } Effects_to_Revs[Profiles] <bgcolor=cGreen, optimize=true>;
    struct {
        byte value[Effects];
    } Effects_to_Speed[Profiles] <bgcolor=cDkGreen, optimize=true>;

    // general table to apply effects on the final sound of every car profile
    if (Gain_table_flag > 0) {
        // this gain table appears only in newer firmware: 5F 0003+, 8S, 8W
        // but 5F 0001, 0002, 8K firmwares dont have it
        struct {
            byte value[Effects];
        } Effects_to_Profiles[Profiles] <bgcolor=cGreen, optimize=true>;
    }
    struct {
        ushort gain[8];
        ushort clip[8];
    } SUM_Gain_Clip <bgcolor=cDkGreen>;

    ushort Acceleration_Scale[Acceleration_length] <bgcolor=cGreen>; // values in [-0.3 - 0.98] range (5F 0003 fw) / [-0.4 - 1.00] range (565 AGA fw)
    ushort Revolutions_Scale[Revolutions_length] <bgcolor=cDkGreen>; // values in [500 - 8150] (rpm) range quanified by 16256
    ushort Speed_Scale[Speed_length] <bgcolor=cGreen>; // values in [0 - 326.39] (km/h) range	
    struct { // LIB_m_Gain
        ushort value[Acceleration_length]; 
    } Acceleration[AccelFunctions] <bgcolor=cDkGreen, optimize=true>;
    struct { // LIB_n_Gain
        ushort value[Revolutions_length]; 
    } Revolutions[RevsFunctions] <bgcolor=cGreen, optimize=true>; 
    struct { // LIB_v_Gain
        ushort value[Speed_length]; 
    } Speed[SpeedFunctions] <bgcolor=cDkGreen, optimize=true>;

    struct { // LIB_Sig
        short value[Sample_length];
    } Samples[Samples_count] <bgcolor=cDkAqua, optimize=true>; 
        
    // Print a report to output 
    Printf("ID\tEngine\tVIN\t\tRelapseKl15\tGearbox\tDefault\tReverse\tComfort\tNormal\tSport\tOffroad\tEco\tRace\tGTE\tHighPass\tRFU2\tRFU3\t\n");
    for( i = 0; i < Profiles; i++ ) {
        Printf("%i\t%02X\t%s\t%i\t%i\t%i\t%i\t%i\t%i\t%i\t%i\t%i\t%i\t%i\t%s\t%i\t%i\n", 
            i+1, 
            Car[i].Engine_code, 
            Car[i].VIN_mask, 
            Car[i].Charisma_01_Switch_Relapse_Clamp15, 
            Car[i].Charisma_02_Switch_Gearbox, 
            Car[i].Charisma_03_Default_driving_profile + 1,// these all need +1 for some reason, unless it's 255 
            Car[i].Charisma_04_Reverse_driving_profile + 1,
            Car[i].Charisma_05_Comfort_driving_profile + 1,
            Car[i].Charisma_06_Normal_driving_profile + 1,
            Car[i].Charisma_07_Sport_driving_profile + 1,
            Car[i].Charisma_08_Offroad_driving_profile + 1,
            Car[i].Charisma_09_Eco_driving_profile + 1,
            Car[i].Charisma_10_Race_driving_profile + 1,
            Car[i].Charisma_11_GTE_driving_profile + 1,
            getFilterProperties(Car[i].HighPass_filter),
            Car[i].Reserved_for_future_use_2,
            Car[i].PHEV_button_led_bits
        );
    } 		
} else if (GEN25) {
    Printf("GEN2.5 firmware\n\n");
    FSeek(160);
    struct {
        ubyte Power_kW <bgcolor=cGreen>;
        ubyte unknown_2 <bgcolor=cDkYellow>; // car Class / Group
        ubyte Engine_code <bgcolor=cDkGreen>;
        char VIN_mask[17] <bgcolor=cGreen>;
        char Transmission <bgcolor=cDkGreen>;   
        char BodyType <bgcolor=cGreen>;
        char Drivetrain <bgcolor=cDkGreen>;
        char FPA_installed <bgcolor=cGreen>;   
        ubyte unknown_25 <bgcolor=cYellow>;
        ubyte FPA_id <bgcolor=cDkGreen>;
    } Car[Profiles];  
    
    struct {
        ubyte unknown[48];
    } MX_Profile[Profiles] <bgcolor=cDkYellow, optimize=true>;

    struct {
        ushort value[14]; // there is NO any param with such a value and sometimes its dynamic and not 14
    } SUM_data[Profiles] <bgcolor=cGreen>;
    struct {
        ushort value[Effects];
    } Gain_Effect[Profiles] <bgcolor=cDkGreen, optimize=true>;
    struct {
        ushort value[Effects];
    } Pitch_Shift_Effect[Profiles] <bgcolor=cGreen, optimize=true>;
    struct {
        ushort value[Effects];
    } Phase_Effect[Profiles] <bgcolor=cDkGreen, optimize=true>;
    struct {
        ushort value[Effects];
    } Delay_Effect[Profiles] <bgcolor=cGreen, optimize=true>;
    struct {
        ubyte value[16];
    } Effects_to_Revs[Profiles] <bgcolor=cDkGreen>;
    ushort Revolutions_Scale[256] <bgcolor=cGreen>; // values in [500 - 8150] (rpm) range quanified by 16256
    struct { 
        ushort value[256]; 
    } Revolutions[16] <bgcolor=cDkGreen>; 
    struct {
        ubyte value[16];
    } Effects_to_Accel[Profiles] <bgcolor=cGreen>;
    ushort Acceleration_Scale[32] <bgcolor=cDkGreen>; // values in [-0.5 - 1.00] range, acceleration 
    struct {
        ushort value[32];
    } Acceleration[8] <bgcolor=cGreen>;
    struct {
        ubyte value[16];
    } Effects_to_Speed[Profiles] <bgcolor=cDkGreen>;
    ushort Speed_Scale[32] <bgcolor=cGreen>; // values in [0 - 326.39] (km/h) range	
    struct {
        ushort value[32];
    } Speed[SpeedFunctions] <bgcolor=cDkGreen>;
    struct {
        ubyte value[16];
    } Effects_to_Pedal[Profiles] <bgcolor=cGreen>;
    ushort Pedal_Scale[32] <bgcolor=cDkGreen>;
    struct {
        ushort value[32];
    } Pedal[4] <bgcolor=cGreen>;

    struct {
        ubyte value[16];
    } Effects_to_Samples[Profiles] <bgcolor=cDkGreen>;
/*
    struct {
        short value[Points_per_Sample];
    } LIB_Sig[Samples] <bgcolor=cDkAqua, optimize=false>; 
*/
    // Print a report to output 
    Printf("CAR\n");
    Printf("ID\tPower kW\tunknown_2\tEngine\tVIN\t\tTransmissn\tBody Type\tDrivetrain\tFPA Flag\tunknown_25\tFPA ID\n");
    
    for( i = 0; i < Profiles; i++ ) {
        Printf("%i\t%i\t%i\t%02X\t%s\t%s\t%s\t%s\t%s\t%i\t%i\n", 
            i + 1, 
            Car[i].Power_kW == 63 ? 0 : Car[i].Power_kW,
            Car[i].unknown_2, 
            Car[i].Engine_code, 
            Car[i].VIN_mask, 
            Car[i].Transmission, 
            Car[i].BodyType, 
            Car[i].Drivetrain,
            (Car[i].FPA_installed == 'J' ? "Yes" : Car[i].FPA_installed == 'N' ? "No" : "Any"),
            Car[i].unknown_25,
            Car[i].FPA_id
        );
    } 	
}

/*

// SHORT spreadsheets 8x12
//PrintSheet12( string name, sheet sheet, int quantizationfactor, string format)"
PrintSheet12_Q16("Spreadsheet 1: ST_Gain", ST_Gain );
PrintSheet12("Spreadsheet 2: ST_Phase ???", ST_Phase, 1, "%.3g\t" );
PrintSheet12("Spreadsheet 3: ST_Pitch_Shift", ST_Pitch_Shift, 65536, "%.3g\t");
PrintSheet12("Spreadsheet 4: ST Delay", ST_Delay, 1, "%i\t" );


// BYTE spreadsheets 8x12
PrintSheet12b("Spreadsheet 5: MX_m_Gain", MX_m_Gain);
PrintSheet12b("Spreadsheet 6: MX_n_Gain", MX_n_Gain);
PrintSheet12b("Spreadsheet 7: MX_v_Gain", MX_v_Gain);
if (Gain_table_flag > 0) {
    PrintSheet12b("Spreadsheet 8: MX Sig", MX_Sig);
}

// USHORT spreadsheet 8x2
PrintSheet2("Spreadsheet 9: SUM_Gain_Clip", SUM_Gain_Clip);

/*
// Increase / Decrease revs scale ???
// could be useful for popcorn effect
Printf("\nSpreadsheet 10: LIB_m_Gain\nHEADER\tDATA\n");
for( i = 0; i < 32; i++ ) {
    Printf("%.2f", (float) LIB_m_Gain_scale[i] / 32768 - 1);
    for( j = 0; j < 8; j++ ) {
        Printf("\t%.4f", (float) LIB_m_Gain_data[j].value[i] / 65536);
    }
    Printf("\n");
}

Printf("\nSpreadsheet 11: LIB_n_Gain_Revs\nHEADER\tDATA\n");
for( i = 0; i < 256; i++ ) {
    Printf("%i", (float) LIB_n_Gain_Revs_scale[i] / 65536 * 16384);
    for( j = 0; j < 16; j++ ) {
        Printf("\t%.4f", (float) LIB_n_Gain[j].value[i] / 65536);
    }
    Printf("\n");
}

Printf("\nSpreadsheet 12: LIB_v_Gain_Speed\nHEADER\tDATA\n");
for( i = 0; i < 32; i++ ) {
    // real scale for this header column is the percentage [0 - 100%] from 326.39 value
    // multipliying it to 3.2639 shows absolute speed
    // (VW e-UP! is limited to 150kmh)
    Printf("%.2f", (float) LIB_v_Gain_Speed_scale[i] / 326.39 * 3.2639);
    for( j = 0; j < 4; j++ ) {
        Printf("\t%.4f", (float) LIB_v_Gain_data[j].value[i] / 65536);
    }
    Printf("\n");
}
/*

Printf("\nSpreadsheet 13: LIB_Sig\nHEADER\tDATA\n");
for( i = 0; i < 1024; i++ ) {
    for( j = 0; j < 16; j++ ) {
        Printf("%i\t", (float) LIB_Sig[j].value[i]);
    }
    Printf("\n");
}
*/

for (k = start;k < end; k += 2) {
    checksum = checksum + ReadUShort(k);
}
checksum = (checksum & 0xffff) ^ 0xffff;
Printf("\nCHECKSUM: %x \n\n", checksum);  